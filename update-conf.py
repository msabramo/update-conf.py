#!/usr/bin/env python
# coding: utf-8
#
# Generate config files from 'conf.d' like directories
#
# Generate a new config file using as base the splitted config dir (default is './conf.d') and the main file.
# If there was no main file, only the splitted config dir will be used. Else, the generated file will start 
# with main config file and continue with the files that exits in the splitted config dir. Files are merged in the
# lexical sort order of their names
# Example:
#     ./update-conf.d.py -f /etc/snmp/snmpd.conf -d /etc/snmp/snmpd.d -m /etc/snmp/snmpd.main
# Commands can be defined in a vlk-conf.d config file. In tis case, you only need to pass the name of commmand.
# Example:
#     ./update-conf.d.py -n snmpd
#
# This software was based in the update-conf.d project
# See: https://github.com/Atha/update-conf.d

# TODO Use better Arg groups
#      See: http://docs.python.org/dev/library/argparse.html#argument-groups

import sys 
import os
import argparse
import ConfigParser
import shutil
import subprocess
import re

# Constants
PROGRAM = sys.argv[0]
PROGRAM_THIN = os.path.basename(PROGRAM)
WORKDIR = os.path.dirname(__file__)
DEFAULT_CONFIG = PROGRAM_THIN + ".conf"
# XXX 'conf.d' or 'snmpd.conf.d'? What is the best default name???
DEFAULT_SPLIT_DIR = "conf.d"
TEMP_END = ".tmp"
BACKUP_END = ".bak"
# Files in 'conf.d' like dir that ends with (.bak,.backup,...) won't be included 
IGNORE_FILES_PATTERN = "\.[bak|backup|old|inactive]"

# Usage
usage_string = """{prog_name} [-h] -n NAME [-c CONF]
         or
       {prog_name} [-h] -f FILE [-d DIR] [-m MAIN]""".format(prog_name=PROGRAM)

# Parsing
parser = argparse.ArgumentParser(usage=usage_string, 
        description="Generate config files from 'conf.d' like directories")
group = parser.add_mutually_exclusive_group()
group.required = True
# Use with command name
group.add_argument("-n", "--name", help="name of a previously defined command")
parser.add_argument("-c", "--conf", help="update-conf.d conf file (default update-conf.py.conf)", 
        default=DEFAULT_CONFIG)
# Use with file name
group.add_argument("-f", "--file", help="configuration file to be generated")
parser.add_argument("-d", "--dir", help="directory where the splitted files are found (default FILE_DIR/conf.d)")
parser.add_argument("-m", "--main", help="main configuration file")
args = parser.parse_args()

# Get (file,dir,main) from command name
# See: http://docs.python.org/2/library/configparser.html#module-ConfigParser
if args.name:
    config_parser = ConfigParser.RawConfigParser()
    # Open config file 
    try:
        config_parser.readfp( open(args.conf) )
    except IOError:
        print "usage: {}".format(usage_string)
        print "{}: error: config file '{}' not found".format(PROGRAM_THIN, args.conf)
        sys.exit(1)
    # Errors
    if not config_parser.has_section( args.name ):
        print "{}: error: invalid command name '{}'".format(PROGRAM_THIN, args.name)
        sys.exit(1)
    if not config_parser.has_option( args.name, 'file' ):
        print "{}: error: required value 'file' not found in {}, section '{}'".format(
                PROGRAM_THIN, args.conf, args.name)
        sys.exit(1)
    # Setting values
    args.file = config_parser.get(args.name,'file')
    if config_parser.has_option(args.name,'dir'):
        args.dir = config_parser.get(args.name,'dir')
    if config_parser.has_option(args.name,'main'):
        args.main = config_parser.get(args.name,'main')

# 'args.dir' default value
if not args.dir:
    args.dir = os.path.dirname(args.file) + os.sep + DEFAULT_SPLIT_DIR

# Creating new file
# Temp file name
temp_file = os.path.abspath(args.file) + TEMP_END
# For prevent wrong result after a previous bug, remove old temp file
if os.path.isfile(temp_file):
    os.remove(temp_file)
# Header
# TODO Add comment pattern as an option (#,;,//)
# subprocess.call("echo '# Auto-generated by update-conf.py' > {}".format(temp_file), shell=True)
# Merge main file
if args.main:
    subprocess.call("cat {} >> {}".format(args.main, temp_file), shell=True)
# Files in splitted conf dir (conf.d like) that not end with .bak, .backup, ...
split_files = [args.dir + os.sep + split_file for split_file in os.listdir(args.dir) if 
        not re.search(IGNORE_FILES_PATTERN, split_file)]
# Merge splitted files
for split_file in split_files:
    subprocess.call("cat {} >> {}".format(split_file, temp_file), shell=True)

# Update conf file making backup
backup_file = os.path.abspath(args.file) + BACKUP_END
if os.path.isfile(args.file):
    shutil.move(args.file, backup_file)
shutil.move(temp_file, args.file)
